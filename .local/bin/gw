#!/bin/bash
# Git worktree helper

set -e

# Globals set by find_worktree
wt_path=""
wt_branch=""

usage() {
    cat <<EOF
Usage: gw <command> [branch] [options]
  add <branch> [--no-cd]  Create worktree at ../<repo>-<branch> with branch <username>/<branch>
  cd [branch]          Change to worktree for <branch>, or main worktree if omitted
  merge [--prune]      Merge current branch into main (cd to main, merge, optionally prune)
  rm <branch>          Remove worktree and delete branch
  ls                   List all worktrees
  prune                Remove worktrees whose branches have been merged
EOF
    exit 1
}

# Find worktree info by branch suffix. Sets $wt_path and $wt_branch.
find_worktree() {
    local branch="$1"
    eval "$(git worktree list --porcelain | awk -v branch="/$branch\$" '
        /^worktree / { path = substr($0, 10) }
        /^branch / {
            br = substr($0, 8)
            if (br ~ branch) { printf "wt_path=\"%s\"\nwt_branch=\"%s\"\n", path, br; exit }
        }
    ')"
    if [[ -z "$wt_path" ]]; then
        echo "No worktree found for branch ending in /$branch" >&2
        exit 1
    fi
}

get_repo_name() {
    basename -s .git "$(git remote get-url origin 2>/dev/null)" 2>/dev/null ||
        basename "$(git rev-parse --show-toplevel)"
}

get_username() {
    gh api user --jq .login 2>/dev/null ||
        git config user.name | tr ' ' '-'
}

cmd_add() {
    local branch="$1" no_cd="$2"
    [[ -z "$branch" ]] && usage

    local repo username worktree_path full_branch
    repo=$(get_repo_name)
    username=$(get_username)
    worktree_path="../${repo}-${branch}"
    full_branch="${username}/${branch}"

    git worktree add -b "$full_branch" "$worktree_path"
    worktree_path=$(cd "$worktree_path" && pwd)
    echo "Created worktree at $worktree_path with branch $full_branch"

    [[ "$no_cd" != "--no-cd" ]] && echo "__gw_cd:$worktree_path:$branch"
}

cmd_cd() {
    if [[ -z "$1" ]]; then
        # No branch specified - return main worktree
        local main_wt main_branch
        main_wt=$(git worktree list --porcelain | awk '/^worktree / { print substr($0, 10); exit }')
        main_branch=$(git -C "$main_wt" symbolic-ref --short HEAD)
        echo "$main_wt:$main_branch"
    else
        find_worktree "$1"
        echo "$wt_path:${wt_branch##*/}"
    fi
}

cmd_merge() {
    local do_prune="$1"
    local current_wt current_branch main_wt main_branch

    current_wt=$(pwd)
    current_branch=$(git symbolic-ref --short HEAD)
    main_wt=$(git worktree list --porcelain | awk '/^worktree / { print substr($0, 10); exit }')
    main_branch=$(git -C "$main_wt" symbolic-ref --short HEAD)

    if [[ "$current_wt" == "$main_wt" ]]; then
        echo "Already in main worktree, nothing to merge" >&2
        exit 1
    fi

    echo "Merging $current_branch into $main_branch..."
    git -C "$main_wt" merge "$current_branch"

    if [[ "$do_prune" == "--prune" ]]; then
        echo "Removing worktree $current_wt and branch $current_branch..."
        git worktree remove "$current_wt"
        git branch -d "$current_branch"
        echo "__gw_cd:$main_wt"
    fi
}

cmd_rm() {
    [[ -z "$1" ]] && usage
    find_worktree "$1"
    git worktree remove "$wt_path"
    git branch -d "$wt_branch"
    echo "Removed worktree $wt_path and branch $wt_branch"
}

cmd_ls() {
    local -a wt_paths=() branches=() pids=()
    local tmpdir
    tmpdir=$(mktemp -d)
    trap 'rm -rf "$tmpdir"' RETURN

    # Collect worktrees and spawn parallel PR lookups
    while IFS= read -r line; do
        if [[ "$line" =~ ^worktree ]]; then
            wt_path="${line#worktree }"
        elif [[ "$line" =~ ^branch ]]; then
            branch="${line#branch refs/heads/}"
            wt_paths+=("$wt_path")
            branches+=("$branch")
            local i=${#branches[@]}
            gh pr view "$branch" --json state,url \
                --jq '"[\(.state)] \(.url)"' >"$tmpdir/$i" 2>/dev/null &
            pids+=($!)
        fi
    done < <(git worktree list --porcelain)

    wait "${pids[@]}" 2>/dev/null

    # Find max branch length for alignment
    local max_branch_len=0
    for branch in "${branches[@]}"; do
        ((${#branch} > max_branch_len)) && max_branch_len=${#branch}
    done

    # Print results
    for i in "${!branches[@]}"; do
        local pr_info="" display_path="${wt_paths[$i]/#$HOME/\~}"
        [[ -s "$tmpdir/$((i+1))" ]] && pr_info=$(cat "$tmpdir/$((i+1))")
        if [[ -n "$pr_info" ]]; then
            printf "%-50s %-${max_branch_len}s  %s\n" "$display_path" "${branches[$i]}" "$pr_info"
        else
            printf "%-50s %s\n" "$display_path" "${branches[$i]}"
        fi
    done
}

cmd_prune() {
    local main_wt main_branch
    main_wt=$(git worktree list --porcelain | awk '/^worktree / { print substr($0, 10); exit }')
    main_branch=$(git -C "$main_wt" symbolic-ref --short HEAD)

    # Collect worktrees to prune
    local -a prune_paths=() prune_branches=()
    while IFS= read -r line; do
        [[ "$line" =~ ^worktree ]] && wt_path="${line#worktree }"
        [[ "$line" =~ ^branch ]] && {
            wt_branch="${line#branch refs/heads/}"
            # Skip the main worktree
            [[ "$wt_path" == "$main_wt" ]] && continue
            # Check if branch is merged into main, has diverged, and worktree is clean
            if git -C "$main_wt" branch --merged "$main_branch" | grep -qE "^[*+]?\s+${wt_branch}\$" &&
               [[ "$(git rev-parse "$wt_branch")" != "$(git rev-parse "$main_branch")" ]] &&
               git -C "$wt_path" diff-index --quiet HEAD -- 2>/dev/null &&
               [[ -z "$(git -C "$wt_path" ls-files --others --exclude-standard)" ]]; then
                prune_paths+=("$wt_path")
                prune_branches+=("$wt_branch")
            fi
        }
    done < <(git worktree list --porcelain)

    if [[ ${#prune_paths[@]} -eq 0 ]]; then
        echo "No worktrees to prune"
        return
    fi

    # Show what will be pruned (write to tty so it's not captured by wrapper)
    {
        echo "The following worktrees will be pruned:"
        for i in "${!prune_paths[@]}"; do
            echo "  ${prune_paths[$i]} (branch ${prune_branches[$i]})"
        done
    } >/dev/tty

    # Ask for confirmation
    read -rp "Proceed? [y/N] " confirm </dev/tty
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Aborted"
        return
    fi

    # Prune confirmed worktrees
    local pruned=0
    for i in "${!prune_paths[@]}"; do
        echo "Pruning ${prune_paths[$i]}..."
        git worktree remove "${prune_paths[$i]}"
        git branch -d "${prune_branches[$i]}"
        ((++pruned))
    done

    echo "Pruned $pruned worktree(s)"
}

case "$1" in
add) cmd_add "$2" "$3" ;;
cd) cmd_cd "$2" ;;
merge) cmd_merge "$2" ;;
rm) cmd_rm "$2" ;;
ls) cmd_ls ;;
prune) cmd_prune ;;
*) usage ;;
esac
